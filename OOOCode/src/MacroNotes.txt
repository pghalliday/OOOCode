Notes on the safe implementation of macros
========================================== 

Variadic macros
---------------

  #define MY_MACRO(FORMAT, ARGS...) O_debug(FORMAT , ##ARGS)

In the above code the ## is necessary so that if no extra arguments are supplied
the preceding comma is removed.

Also note that there is a space before the comma, this is necessary or the ##
does not work.

  #define MY_MACRO(FUNCTION_NAME, ARGS...) FUNCTION_NAME(ARGS)

In the above code we could still use the ## but it gives an annoying warning
as there is no valid token before it for removal so we shouldn't use it

Argument passing
----------------

In order to support #defined values being passed into macros the following
construction is used:

  #define _MY_MACRO(FORMAT, ARGS...) O_debug(FORMAT , ##ARGS)
  #define MY_MACRO(FORMAT, ARGS...) _MY_MACRO(FORMAT , ##ARGS)

This extra level of indirection allows calls like this:

  #define FORMAT	"Hello, %s!\n"
  MY_MACRO(FORMAT, "world");

Without the indirection the above would not compile as FORMAT would be used
in the O_debug call without expansion (and it is not a valid string or variable)

Sometimes we need another level of indirection as in the following example

  #define __MY_MACRO(FORMAT, ARGS...) O_debug(FORMAT , ##ARGS)
  #define _MY_MACRO(FORMAT, ARGS...) __MY_MACRO(FORMAT , ##ARGS)
  #define MY_MACRO(ARGS...) __MY_MACRO(STANDARD_FORMAT , ##ARGS)

We may do this if we want to have a standard parameter defined that can then
be used in multiple macros and/or macro calls as in the following example

  #define STANDARD_FORMAT	"Hello, %s!\n"
  MY_MACRO("world");
  MY_MACRO("other worlds");

Making multiple statements look like one
----------------------------------------

Sometimes a macro expands to multiple statements but needs to be treated as
a single statement. Consider the following code:

  if (x == y)
  	MY_MACRO("x is equal to y\n");

This is a single line if really as it does not use curly braces. Now consider
this macro definition:

  #define MY_MACRO(TEXT) \
    assert(TEXT); \
    O_debug(TEXT)
    
When we execute this code we will always print out that x equals y whether it
does or not. This is because it expands to this:

  if (x == y)
    assert("x is equal to y\n");
  O_debug("x is equal to y\n");

NB. I took liberties with the white space to make it clearer.

To work round this problem we can use a do{...}while(...) construction to make
it look like a single statement:

  #define MY_MACRO(TEXT) \
    do \
    { \
      assert(TEXT); \
      O_debug(TEXT); \
    } \
    while(0)
    
This creates a loop that is only run once and looks like a single statement
